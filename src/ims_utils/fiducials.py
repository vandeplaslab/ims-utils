"""File containing utility functions for fiducials."""

import typing as ty

import numpy as np


def distance2line(p1: ty.Sequence[int], p2: ty.Sequence[int], p3: ty.Sequence[int]) -> float:
    """
    Returns the distance of the point `p3` to the line passing through `p1` and `p2`.

    Args:
        `p1`: The first point on the line
        `p2`: The second point on the line
        `p3`: The point to compute its distance to the line.

    Returns:
        The distance of `p3` to the line
    """
    dist = np.abs((p2[0] - p1[0]) * (p1[1] - p3[1]) - (p1[0] - p3[0]) * (p2[1] - p1[1]))
    dist = dist / np.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]))
    return dist


def simplify_contour(contours: list[np.ndarray], d: float) -> list[np.ndarray]:
    """
    Given a contour as a sequence of points, it returns a simplified version based on the distance parameter `d`.
    Larger valued of `d` results in simpler contours but less similar to the original contour.

    Args:
        `contours`: a sequence of contours generated by opencv
        `d`: the tuning parameter for the amount of simplification.

    Returns:
        A sequence of simplified contours
    """
    simp = []
    for contour in contours:
        left = 0
        right = 2
        res = [contour[0]]

        while right < len(contour):
            p1 = contour[left][0]
            p2 = contour[right][0]
            p3 = contour[right - 1][0]
            dist = distance2line(p1, p2, p3)
            if dist > d:
                left = right - 1
                res.append(contour[left])
            right += 1
        simp.append(np.array(res))
    return simp


def find_contours(image: np.ndarray) -> list[np.ndarray]:
    """Find contours in image."""
    import cv2

    if hasattr(image, "compute"):
        image = image.compute()
    # pre-process image
    image = np.nan_to_num(image, nan=0)
    image = cv2.normalize(image, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
    image[image > 1] = 255

    # detect contours and filter
    contours, _ = cv2.findContours(image, mode=cv2.RETR_TREE, method=cv2.CHAIN_APPROX_SIMPLE)
    return contours


def contour_formatter(contours: list[np.ndarray]) -> list[str]:
    """Format contours."""
    from natsort import index_natsorted, order_by_index

    # create options
    options = [f"Contour {i} ({len(c)} points)" for (i, c) in enumerate(contours)]
    # sort by the number of points
    indices = index_natsorted([len(c) for c in contours], reverse=True)
    options = order_by_index(options, indices)
    return options


def contour_to_points(contour: np.ndarray) -> np.ndarray:
    """Convert contour to points."""
    return np.squeeze(contour)


def filter_contours(contours: list[np.ndarray], n_min: int = 2) -> list[np.ndarray]:
    """Filter contours."""
    return [c for c in contours if len(c) >= n_min]
